# Механизм генерации SSCC-кодов в Datamatrix-app

Этот документ описывает внутреннее устройство, технологические решения и защитные механизмы, реализованные в модуле генерации кодов SSCC (Serial Shipping Container Code) в приложении `datamatrix-app`.

Основная задача модуля — гарантировать создание **уникальных, валидных и не повторяющихся** 18-значных кодов SSCC для логистических единиц (коробов, паллет) в соответствии со стандартом GS1.

## 1. Структура и логика генерации SSCC

Каждый сгенерированный SSCC-код состоит из нескольких логических частей:

`[Extension Digit (1)][GCP (12)][Serial Number (4)][Check Digit (1)]`

*   **Extension Digit (Цифра расширения)**: 1 цифра. Используется для расширения диапазона доступных номеров. В текущей реализации она вычисляется на основе глобального счетчика и может принимать значения от 1 до 9.
*   **GCP (Global Company Prefix)**: 12 цифр. Это префикс компании, зарегистрированный в GS1. В системе он задан как константа `466941739999`.
*   **Serial Number (Серийный номер)**: 4 цифры. Уникальный номер внутри комбинации GCP и Extension Digit.
*   **Check Digit (Контрольная цифра)**: 1 цифра. Рассчитывается по стандартному алгоритму GS1 и служит для проверки целостности кода при сканировании.

Таким образом, для одного GCP система может сгенерировать `9 (Extension Digits) * 10,000 (Serial Numbers) = 90,000` уникальных SSCC-кодов.

## 2. Ключевые технологические решения

Для обеспечения надежности и уникальности кодов применены два ключевых решения.

### Атомарный счетчик в PostgreSQL

Чтобы избежать "гонки состояний" (race condition), когда несколько параллельных процессов могут попытаться получить один и тот же номер, используется механизм блокировки на уровне базы данных.

Функция `read_and_increment_counter` атомарно получает и обновляет значение счетчика в таблице `system_counters` внутри одной транзакции.

**Фрагмент кода (`aggregation_service.py`):**
```python
def read_and_increment_counter(cursor, counter_name: str, increment_by: int = 1) -> tuple[int, str | None]:
    """
    Атомарно читает и увеличивает счетчик в БД.
    """
    # Блокирует строку счетчика до завершения транзакции,
    # предотвращая чтение этого значения другими процессами.
    cursor.execute(
        "SELECT current_value FROM system_counters WHERE counter_name = %s FOR UPDATE;",
        (counter_name,)
    )
    current_value = cursor.fetchone()[0]
    new_value = current_value + increment_by

    # ... (логика проверки переполнения) ...

    cursor.execute(
        "UPDATE system_counters SET current_value = %s WHERE counter_name = %s;",
        (new_value, counter_name)
    )
    
    return new_value, warning_message
```
Использование `FOR UPDATE` гарантирует, что каждый вызов функции вернет абсолютно уникальное значение, даже при высокой нагрузке на систему.

### Реализация алгоритма GS1 Check Digit

Для валидации кодов реализована функция `calculate_sscc_check_digit`, которая в точности следует алгоритму GS1: каждый нечетный символ (справа налево) умножается на 3, каждый четный — на 1, результаты суммируются, и контрольная цифра вычисляется как остаток от деления на 10.

**Фрагмент кода (`aggregation_service.py`):**
```python
def calculate_sscc_check_digit(base_sscc: str) -> int:
    """Вычисляет контрольную цифру для 17-значного SSCC по алгоритму GS1."""
    if len(base_sscc) != 17:
        raise ValueError("База для SSCC должна содержать 17 цифр")
    total_sum = 0
    for i, digit_char in enumerate(reversed(base_sscc)):
        digit = int(digit_char)
        if i % 2 == 0:
            total_sum += digit * 3
        else:
            total_sum += digit * 1
    return (10 - (total_sum % 10)) % 10
```

## 3. Защита от переполнения и мониторинг

Ресурс SSCC-кодов для одного GCP конечен. В системе реализована **двухуровневая защита** от исчерпания этого ресурса, которая работает внутри функции `read_and_increment_counter`.

### Уровень 1: Предупреждение (Warning)

*   **Порог срабатывания**: `SSCC_WARNING_THRESHOLD = 80,000` (из `90,000` возможных).
*   **Логика**: Когда значение счетчика достигает этого порога, система генерирует сообщение с предупреждением и добавляет его в лог обработки заказа.
*   **Цель**: Заблаговременно уведомить администраторов о том, что диапазон номеров подходит к концу. Это дает время на планирование перехода на новый GCP без остановки рабочих процессов.

### Уровень 2: Критическая ошибка (Hard Stop)

*   **Порог срабатывания**: `SSCC_TOTAL_CAPACITY = 90,000`.
*   **Логика**: Если счетчик достигает максимальной емкости, функция генерирует исключение `ValueError`. Это немедленно останавливает выполнение всего процесса агрегации.
*   **Цель**: Это механизм "последней инстанции", который **гарантирует**, что система никогда не сгенерирует дублирующийся SSCC-код. Возникшее исключение приводит к откату транзакции в базе данных, предотвращая запись некорректных данных.

**Фрагмент кода с реализацией защиты (`aggregation_service.py`):**
```python
def read_and_increment_counter(cursor, counter_name: str, increment_by: int = 1):
    # ... (получение new_value) ...
    
    warning_message = None
    if counter_name == 'sscc_id':
        # Уровень 2: Критическая ошибка
        if new_value >= SSCC_TOTAL_CAPACITY:
            raise ValueError(
                f"КРИТИЧЕСКАЯ ОШИБКА: Счетчик SSCC ИСЧЕРПАН (id={new_value})! ..."
            )
        # Уровень 1: Предупреждение
        elif new_value >= SSCC_WARNING_THRESHOLD:
            remaining = SSCC_TOTAL_CAPACITY - new_value
            warning_message = (
                f"!!! ВНИМАНИЕ: Ресурс счетчика SSCC подходит к концу. ..."
            )
    # ... (обновление счетчика) ...
    return new_value, warning_message
```

Такая архитектура обеспечивает не только генерацию валидных кодов, но и высокую степень надежности и отказоустойчивости системы в долгосрочной перспективе.