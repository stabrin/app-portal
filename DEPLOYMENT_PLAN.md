# План развертывания и обновления продуктового сервера

Этот документ описывает пошаговую процедуру безопасного обновления продуктового сервера, включая создание резервной копии данных, слияние веток в Git и развертывание изменений.

**Цель:** Обновить приложение на продуктовом сервере, внедрив функционал из ветки разработки (например, с поддержкой SSL для PostgreSQL), не потеряв при этом существующие данные.

---

## Шаг 1: Подготовка и Резервное копирование (на продуктовом сервере)

**Никогда не пропускайте этот шаг!**

1.  **Подключитесь к продуктовому серверу** по SSH.

2.  **Определите имя Docker-контейнера** с базой данных PostgreSQL. Обычно его можно найти, выполнив команду:

    ```bash
    docker ps
    ```
    Найдите в списке контейнер с образом `postgres` и запомните его имя (например, `app-portal-db-1`).

3.  **Создайте резервную копию базы данных.** Выполните следующую команду, подставив свои значения:

    *   `[имя_контейнера_бд]` — имя вашего Docker-контейнера с PostgreSQL.
    *   `[имя_пользователя_бд]` — имя пользователя для подключения к БД (из `.env` файла).

    ```bash
    # Команда создаст файл .sql с полной резервной копией базы данных
    docker exec -t [имя_контейнера_бд] pg_dumpall -c -U [имя_пользователя_бд] > dump_$(date +%Y-%m-%d_%H-%M-%S).sql
    ```

    **Пример:**
    ```bash
    docker exec -t app-portal-db-1 pg_dumpall -c -U postgres > dump_2025-11-03.sql
    cat dump_2025-11-03.sql | docker exec -i portal_postgres_db psql -U portal_user -d postgres
    ```

4.  **Проверьте, что бэкап создан.** Убедитесь, что в текущей папке появился `.sql` файл ненулевого размера. Сохраните его в надежном месте.

5.  **Добавьте бэкапы в `.gitignore` (если этого не было сделано ранее).** Чтобы случайно не добавить большой файл бэкапа в репозиторий, создайте или отредактируйте файл `.gitignore` в корне проекта и добавьте в него следующую строку:

    ```gitignore
    # Игнорировать SQL дампы
    dump_*.sql
    ```
    Это заставит Git игнорировать все файлы, начинающиеся с `dump_` и заканчивающиеся на `.sql`.

---

## Шаг 2: Слияние веток в Git (на вашем локальном компьютере)

Этот шаг объединяет код из ветки разработки в основную ветку `main`.

1.  **Переключитесь на вашу ветку разработки** (например, `feature-development`) и убедитесь, что все последние изменения закоммичены и отправлены на сервер.

    ```bash
    git checkout feature-development
    git pull origin feature-development
    ```

2.  **Обновите ветку разработки** последними изменениями из `main`. Это поможет выявить конфликты на вашей стороне, а не в `main`.

    ```bash
    git pull origin main
    ```
    *Если возникнут конфликты, решите их, сделайте коммит и отправьте изменения (`git push`).*

3.  **Переключитесь на основную ветку `main`** и загрузите последние изменения.

    ```bash
    git checkout main
    git pull origin main
    ```

4.  **Выполните слияние** ветки разработки в `main`.

    ```bash
    git merge feature-development
    ```

5.  **Отправьте обновленную ветку `main`** на удаленный сервер.

    ```bash
    git push origin main
    ```

Теперь в ветке `main` находится актуальный код, готовый к развертыванию.

---

## Шаг 3: Обновление продуктового сервера

1.  **Подключитесь к продуктовому серверу** по SSH и перейдите в папку проекта.

2.  **Обновите код из Git**, загрузив последние изменения из ветки `main`.

    ```bash
    git checkout main
    git pull origin main
    ```

    > **Возможная ошибка при `git pull`**
    > Если вы ранее делали коммиты прямо на сервере, `git pull` может выдать ошибку `fatal: Need to specify how to reconcile divergent branches`.
    >
    > **Решение:**
    > 1.  Однократно выполните `git pull --rebase origin main` для синхронизации.
    > 2.  Чтобы настроить поведение по умолчанию и избежать этой ошибки в будущем, выполните:
    >     ```bash
    >     git config --global pull.rebase true
    >     ```

3.  **Сгенерируйте сертификаты для продуктового сервера.** Запустите обновленный скрипт `prepare_certs.sh`, указав через пробел **все доменные имена и IP-адреса**, по которым будет осуществляться доступ.

    ```bash
    # Команда для вашего продуктового сервера:
    ./prepare_certs.sh beeb09fc2128.sn.mynetname.net 88.86.80.143 80.80.101.169 192.168.108.95
    ```
    Скрипт создаст папку `secrets/postgres` с файлами `server.crt` и `server.key`.

4.  **Установите правильные права на ключ.** Это критически важно для PostgreSQL.

    ```bash
    sudo chown 70:70 ./secrets/postgres/server.key
    sudo chmod 600 ./secrets/postgres/server.key
    ```

5.  **Обновите `docker-compose.yml`**.
    *   Добавьте в сервис базы данных (`db`) команды для включения SSL и монтирование папки с сертификатами.
    *   **Явно укажите подсеть** для вашей внутренней сети. Это повысит безопасность и позволит `pg_hba.conf` работать корректно.

    ```yaml
    # docker-compose.yml

    services:
      db: # или postgres, как он у вас называется
        # ... ваши текущие настройки ...
        volumes:
          - ./secrets/postgres:/etc/ssl/postgres:ro # Монтируем сертификаты
          - ./pg_hba.conf:/etc/postgresql/pg_hba.conf:ro # Монтируем наш кастомный pg_hba.conf
          - pg_data:/var/lib/postgresql/data
        command: >
          -c ssl=on
          -c ssl_cert_file=/etc/ssl/postgres/server.crt
          -c ssl_key_file=/etc/ssl/postgres/server.key
          -c hba_file=/etc/postgresql/pg_hba.conf # Явно указываем путь к нашему файлу

    networks:
      default:
        driver: bridge
        ipam:
          config:
            - subnet: 172.19.0.0/16 # Убедитесь, что эта подсеть совпадает с той, что в pg_hba.conf
    ```

6.  **Проверьте `.env` файл.** Убедитесь, что в нем **ОТСУТСТВУЮТ** переменные `DB_SSL_MODE` и `DB_SSL_ROOTCERT`. Это заставит приложение подключаться к базе данных без шифрования, как и требуется для внутренней сети.

    ```env
    # ... существующие переменные ...

    # Убедитесь, что здесь НЕТ строк DB_SSL_MODE и DB_SSL_ROOTCERT
    ```

7.  **Пересоберите и перезапустите Docker-контейнеры**, чтобы применить все изменения.

    ```bash
    docker-compose up -d --force-recreate --build
    ```

8.  **Проверьте логи** приложения и базы данных, чтобы убедиться, что все запустилось успешно и SSL-соединение установлено.

    ```bash
    # Показать логи всех сервисов
    docker-compose logs -f

    # Показать логи конкретного приложения
    docker-compose logs -f dmkod-integration-app
    ```

После выполнения этих шагов ваш продуктовый сервер будет обновлен, а данные останутся в целости и сохранности.

---

## Шаг 4: Настройка внешнего доступа к PostgreSQL по SSL

Этот раздел описывает, как настроить безопасное подключение к базе данных извне (например, с локального компьютера разработчика через DBeaver).

### 1. Проброс порта на роутере (фаерволе)

beeb09fc2128.sn.mynetname.net
88.86.80.143
80.80.101.169

Необходимо создать правило переадресации портов на вашем сетевом оборудовании.

*   **Протокол:** `TCP`
*   **Внешний порт:** `5432` (или любой другой, который вы выберете)
*   **Внутренний IP-адрес:** Локальный IP вашего сервера (например, `192.168.108.95`)
*   **Внутренний порт:** `5432`

### 2. Проверка `docker-compose.yml`

Убедитесь, что в файле `docker-compose.yml` для сервиса базы данных порт опубликован для внешнего доступа:

```yaml
ports:
  - "5432:5432"
```

### 3. Настройка клиента (например, DBeaver)

1.  **Скопируйте сертификат `server.crt`** с сервера на ваш компьютер.
2.  В настройках соединения укажите:
    *   **Хост:** Публичный IP-адрес или домен вашего сервера.
    *   **Порт:** Внешний порт, который вы настроили на роутере (например, `5432`).
3.  Перейдите на вкладку **SSL** и настройте:
    *   **Использовать SSL:** Да.
    *   **Режим SSL:** `verify-full`.
    *   **Корневой сертификат:** Укажите путь к скопированному файлу `server.crt`.