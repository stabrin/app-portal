# План развертывания и обновления продуктового сервера

Этот документ описывает пошаговую процедуру безопасного обновления продуктового сервера, включая создание резервной копии данных, слияние веток в Git и развертывание изменений.

**Цель:** Обновить приложение на продуктовом сервере, внедрив функционал из ветки разработки (например, с поддержкой SSL для PostgreSQL), не потеряв при этом существующие данные.

---

## Шаг 1: Подготовка и Резервное копирование (на продуктовом сервере)

**Никогда не пропускайте этот шаг!**

1.  **Подключитесь к продуктовому серверу** по SSH.

2.  **Определите имя Docker-контейнера** с базой данных PostgreSQL. Обычно его можно найти, выполнив команду:

    ```bash
    docker ps
    ```
    Найдите в списке контейнер с образом `postgres` и запомните его имя (например, `app-portal-db-1`).

3.  **Создайте резервную копию базы данных.** Выполните следующую команду, подставив свои значения:

    *   `[имя_контейнера_бд]` — имя вашего Docker-контейнера с PostgreSQL.
    *   `[имя_пользователя_бд]` — имя пользователя для подключения к БД (из `.env` файла).

    ```bash
    # Команда создаст файл .sql с полной резервной копией базы данных
    docker exec -t [имя_контейнера_бд] pg_dumpall -c -U [имя_пользователя_бд] > dump_$(date +%Y-%m-%d_%H-%M-%S).sql
    ```

    **Пример:**
    ```bash
    docker exec -t app-portal-db-1 pg_dumpall -c -U postgres > dump_2025-11-01_15-30-00.sql
    ```

4.  **Проверьте, что бэкап создан.** Убедитесь, что в текущей папке появился `.sql` файл ненулевого размера. Сохраните его в надежном месте.

---

## Шаг 2: Слияние веток в Git (на вашем локальном компьютере)

Этот шаг объединяет код из ветки разработки в основную ветку `main`.

1.  **Переключитесь на вашу ветку разработки** (например, `feature-development`) и убедитесь, что все последние изменения закоммичены и отправлены на сервер.

    ```bash
    git checkout feature-development
    git pull origin feature-development
    ```

2.  **Обновите ветку разработки** последними изменениями из `main`. Это поможет выявить конфликты на вашей стороне, а не в `main`.

    ```bash
    git pull origin main
    ```
    *Если возникнут конфликты, решите их, сделайте коммит и отправьте изменения (`git push`).*

3.  **Переключитесь на основную ветку `main`** и загрузите последние изменения.

    ```bash
    git checkout main
    git pull origin main
    ```

4.  **Выполните слияние** ветки разработки в `main`.

    ```bash
    git merge feature-development
    ```

5.  **Отправьте обновленную ветку `main`** на удаленный сервер.

    ```bash
    git push origin main
    ```

Теперь в ветке `main` находится актуальный код, готовый к развертыванию.

---

## Шаг 3: Обновление продуктового сервера

1.  **Подключитесь к продуктовому серверу** по SSH и перейдите в папку проекта.

2.  **Обновите код из Git**, загрузив последние изменения из ветки `main`.

    ```bash
    git checkout main
    git pull origin main
    ```

3.  **Сгенерируйте сертификаты для продуктового сервера.** Запустите скрипт `prepare_certs.sh`, указав **домен и IP-адрес вашего продуктового сервера**.

    ```bash
    # Пример для вымышленного сервера my-prod.com с IP 1.2.3.4
    ./prepare_certs.sh my-prod.com 1.2.3.4
    ```
    Скрипт создаст папку `secrets/postgres` с файлами `server.crt` и `server.key`.

4.  **Установите правильные права на ключ.** Это критически важно для PostgreSQL.

    ```bash
    sudo chown 70:70 ./secrets/postgres/server.key
    sudo chmod 600 ./secrets/postgres/server.key
    ```

5.  **Обновите `docker-compose.yml`**.
    *   Добавьте в сервис базы данных (`db`) команды для включения SSL и монтирование папки с сертификатами.
    *   **Явно укажите подсеть** для вашей внутренней сети. Это повысит безопасность и позволит `pg_hba.conf` работать корректно.

    ```yaml
    # docker-compose.yml

    services:
      db: # или postgres, как он у вас называется
        # ... ваши текущие настройки ...
        volumes:
          - ./secrets/postgres:/etc/ssl/postgres:ro # Монтируем сертификаты
          - ./pg_hba.conf:/etc/postgresql/pg_hba.conf:ro # Монтируем наш кастомный pg_hba.conf
          - pg_data:/var/lib/postgresql/data
        command: >
          -c ssl=on
          -c ssl_cert_file=/etc/ssl/postgres/server.crt
          -c ssl_key_file=/etc/ssl/postgres/server.key
          -c hba_file=/etc/postgresql/pg_hba.conf # Явно указываем путь к нашему файлу

    networks:
      default:
        driver: bridge
        ipam:
          config:
            - subnet: 172.19.0.0/16 # Убедитесь, что эта подсеть совпадает с той, что в pg_hba.conf
    ```

6.  **Проверьте `.env` файл.** Убедитесь, что в нем **ОТСУТСТВУЮТ** переменные `DB_SSL_MODE` и `DB_SSL_ROOTCERT`. Это заставит приложение подключаться к базе данных без шифрования, как и требуется для внутренней сети.

    ```env
    # ... существующие переменные ...

    # Убедитесь, что здесь НЕТ строк DB_SSL_MODE и DB_SSL_ROOTCERT
    ```

7.  **Пересоберите и перезапустите Docker-контейнеры**, чтобы применить все изменения.

    ```bash
    docker-compose up -d --force-recreate --build
    ```

8.  **Проверьте логи** приложения и базы данных, чтобы убедиться, что все запустилось успешно и SSL-соединение установлено.

    ```bash
    # Показать логи всех сервисов
    docker-compose logs -f

    # Показать логи конкретного приложения
    docker-compose logs -f dmkod-integration-app
    ```

После выполнения этих шагов ваш продуктовый сервер будет обновлен, а данные останутся в целости и сохранности.